<!-- public/index.html -->
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Train seats monitor â€” demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* styles */
    body{
      font-family:Arial,Helvetica,sans-serif;
      background:#f7f7f7;
      padding:2vh
    }
    h1{
      text-align:center
    }
    /* container for search field and buttons*/
    #search{
      display:flex;
      justify-content:center;
      gap:10px;
      margin:20px;
    }
    /* conteiner for train and legend*/
    .train-container {
      display: flex;
      flex-direction: column;
      margin-top: 2vh;
      justify-content: space-evenly;
      padding-bottom: 3vw;
      margin-left: 2vw;
      margin-right: 2vw;
    }
    /* train cars container */
    #train {
      display: inline-flex;
      overflow-x: auto;         
      overflow-y: hidden;
      scroll-behavior: smooth;  
      flex-direction: row;
      flex-wrap: nowrap;        
      gap: 20px;                     
      padding: 0 12px; /* prevent first/last cars from touching edges */
    }
    /* each car */
    .car {
      flex: 0 0 220px;                      
      padding: 10px;
      display: flex;
      flex-direction: column;
      align-items: center; 
      border-radius: 8px;
    }  
    /* car number */
    .num {
      font-size: 16px;
      margin-bottom: 8px;
      color: black;
    }
    /* seats grid inside car */
    .seats{
      height: 150px;
      flex-direction:column;
      width: 100%; 
      display:flex;
      gap:20px;
      border-radius:8px;
      margin-top:4px;
      box-shadow:0 2px 6px rgba(0,0,0,0.12);
      background:#eee; 
      padding:5%;
      aspect-ratio: 2;
    }
    /* each row of seats */
    .seats-row {
      min-height: 0; 
      display: flex; 
      flex: 1; 
      gap: 5px;
    }
    /* each seat */
    .seat{
      min-height: 2vh;
      flex: 1; 
      border-radius:6px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:13px;
      font-weight:700;
      color:#000;
    }
    /* legend below train */
    .legend{
      gap:14px; 
      margin-top: 1vh; 
      margin-bottom: 1vh;
      justify-content: center; 
      align-items: center;
    }
    /* colored dot in legend */
    .dot{
      width:16px;
      height:16px;
      display:inline-block;
      border-radius:3px;
      margin-right: 6px;
    }
    /* gap between middle rows */
    .middle-gap {
      margin-bottom: 20px;
    }
    /* button to toggle views */
    #viewToggle button {
      padding: 6px 14px;
      border: 1px solid #aaa;
      border-radius: 6px;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    #viewToggle button.active {
      background: #4285f4;
      color: white;
      border-color: #4285f4;
    }
    /* button to find nearest train */
    #nearestBtn {
      background: #eee;
      border: 1px solid #aaa;
      border-radius: 6px;
      cursor: pointer;
      padding: 6px 12px;
      white-space: nowrap;
    }
    /* button to check train number */
    #checkBtn {
      background: #eee;
      border: 1px solid #aaa;
      border-radius: 6px;
      cursor: pointer;
      padding: 6px 12px;
      white-space: nowrap;
    }
    #nearestBtn:hover {
      background: #ddd;
    }
    /* amount of free seats text inside car in train view */
    .free-seats-text {
      display: flex;
      justify-content: center; 
      align-items: center;     
      height: 100%;            
      width: 100%;
      font-weight: 700;
    }

    #trainInput {
      flex: 1 1 auto; 
      min-width: 100px; 
      max-width: 200px;
    }

    /* Upcoming trains container */
    .upcoming-container {
      margin-top: 14px;
      display: none; /* shown when data is available */
      width: 75%;
      margin-left: auto;
      margin-right: auto;
    }
    .upcoming-header {
      font-weight: 600;
      margin-bottom: 6px;
      text-align: center;
      color: #333;
    }
    .upcoming-list {
      max-height: 140px;
      overflow-y: auto;
      background: #fff; /* light theme to match page */
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      padding: 0;
      color: #222;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 15px;
      line-height: 1.25;
    }
    .board-grid {
      display: grid;
      grid-template-columns: 1.2fr 2fr 0.9fr 1fr 0.9fr; /* Train, Destination, Gate, Date, Time */
      column-gap: 12px;
      align-items: center;
    }
    .board-header {
      position: sticky;
      top: 0;
      z-index: 1;
      background: #f5f6f8;
      color: #555;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 11px;        /* a bit more compact */
      padding: 6px 12px;      /* reduce vertical padding */
      border-bottom: 1px solid #e6e6e6;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
    }
    .upcoming-item {
      padding: 6px 12px;      /* reduce vertical padding to fit more rows */
      border-bottom: 1px solid #eee;
      cursor: pointer;
    }
    .upcoming-item:last-child { border-bottom: none; }
    .upcoming-item:nth-child(odd) { background: #fafafa; }
    .upcoming-item:hover { background: #f7f7f7; }
    .board-cell { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .board-train { font-weight: 700; color: #111; }
    .board-time { font-variant-numeric: tabular-nums; color: #555; }

    /* Best car recommendation box (full-width bar by default) */
    .best-car-box {
      position: static; /* always act like the narrow-screen bar */
      width: 100%;
      box-sizing: border-box;
      margin: 8px 0 6px 0;
      background: linear-gradient(135deg,#ffffff 0%, #edfff5 100%);
      border: 2px solid #0b5;
      border-radius: 12px;
      padding: 14px 18px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.10);
      font-size: 16px;
      font-weight: 700;
      color: rgb(0, 0, 0);
      z-index: 850;
      max-width: none;
      line-height: 1.35;
      text-align: center;
      min-height: 60px; /* keep size consistent between states */
    }
    /* Full-train state */
    .best-car-box.full {
      background: #ffe6e6;
      border-color: #d00;
      color: #a00;
    }
    .best-car-box .car-num { color:#0b5; font-weight:800; font-size:1.5em; }

    @media (max-width: 1100px) {
      /* Provide consistent inner padding so children have a small gap from screen edges */
      .train-container {
        margin-left: 0;
        margin-right: 0;
        padding-left: 12px;
        padding-right: 12px;
      }
      /* Ensure symmetric spacing from both edges on narrow screens */
      .current-train-bar {
        display:flex;
        width: 100%;
        box-sizing: border-box;
        margin: 8px 0 4px 0;
      }
    }

    /* Horizontal bar variant (hidden by default, shown on narrow screens) */
    .current-train-bar {
      display:flex;
      width:100%;
      margin:8px auto 4px auto;
      background:#fff;
      border:1px solid #ddd;
      border-radius:8px;
      box-shadow:0 2px 6px rgba(0,0,0,0.08);
      padding:6px 10px;
      font-size:14px;
      gap:18px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      font-variant-numeric:tabular-nums;
    }
    .current-train-bar span { white-space:nowrap; }
    .current-train-bar .label { color:#666; margin-right:4px; font-weight:500; }
    .current-train-bar .value { font-weight:600; color:#111; }
    /* Left-side static label for the current train bar */
    .current-train-bar:before {
      content: "Current Train:    ";
      font-weight:700;
      margin-right:14px;
      color:#0a0a0a;
      letter-spacing:0.5px;
    }

  </style>
</head>
<body>
  <h1>Real-Time Train Monitor</h1>
  <!-- toggles for main views -->
  <div id="viewToggle" style="display:flex;justify-content:center;gap:10px;margin-bottom:10px">
    <button id="trainViewBtn">ðŸš† Train view</button>
    <button id="seatsViewBtn" class="active">ðŸ’º Seats view</button>
  </div>
  <!-- search field and buttons-->
  <div id="search">
    <input type="number" id="trainInput" placeholder="Train number" />
    <button id="checkBtn">Check</button>
    <button id="nearestBtn">Find nearest train</button>
  </div>
  <!-- train and legend container -->
  <div class="train-container">
  <!-- Always-visible recommendation and current train bar above cars -->
  <div id="bestCarBox" class="best-car-box" style="display:none"></div>
  <div id="currentTrainBar" class="current-train-bar" style="display:none"></div>
    <div id="train"></div>
    <div class="legend" style="display:none" id="legend">
      </div>
    <!-- Upcoming trains list (below diagram and legend) -->
    <div id="upcomingTrains" class="upcoming-container">
      <div class="upcoming-header">Upcoming trains</div>
      <div id="upcomingList" class="upcoming-list"></div>
    </div>
  </div>
    
  <script type="module">
    // Firebase setup
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-app.js';
    import { getDatabase, ref, onValue, get } from 'https://www.gstatic.com/firebasejs/12.2.1/firebase-database.js';
    const firebaseConfig = {
      apiKey: "AIzaSyCGbpMrhaH8YEkw_W9sejNX3DAPbGailI8",
      authDomain: "iot2025-56325.firebaseapp.com",
      databaseURL: "https://iot2025-56325-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "iot2025-56325",
      storageBucket: "iot2025-56325.firebasestorage.app",
      messagingSenderId: "606759241623",
      appId: "1:606759241623:web:1335d0d444eb4d242b66d2"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // App logic
    const trainEl = document.getElementById('train');
    const legendEl = document.getElementById('legend');
    const checkBtn = document.getElementById('checkBtn');
    const trainInput = document.getElementById('trainInput');
    const trainViewBtn = document.getElementById('trainViewBtn');
    const seatsViewBtn = document.getElementById('seatsViewBtn');
    const nearestBtn = document.getElementById('nearestBtn');
    const upcomingContainer = document.getElementById('upcomingTrains');
    const upcomingListEl = document.getElementById('upcomingList');
    const currentTrainBar = document.getElementById('currentTrainBar');
    const bestCarBox = document.getElementById('bestCarBox');

    //constants and global variables
    const TOTAL_SEATS_PER_ROW = 8;  
    const TOTAL_ROWS_PER_CAR = 4; 
    const OCCUPIED_THRESHOLD = 70;

    //default view is to show seats
    let currentView = 'seats';

    //variable to hold latest data for re-rendering
    let latestCarIds = null;
    let latestCarsData = null;

    // unsubscribe function for Firebase listeners
    let unsub = null;
    let carUnsubscribes = [];
  let scheduleUnsub = null;
    // simple render scheduler to avoid thrashing the DOM and to allow smooth transitions
    let renderPending = false;

    function scheduleRender() {
      if (renderPending) return;
      renderPending = true;
      requestAnimationFrame(() => {
        renderPending = false;
        if (latestCarIds && latestCarsData) {
          render(latestCarIds, latestCarsData);
          legendEl.style.display = 'flex';
        }
      });
    }

    // build seats object for a car, if seats are missing, fill with fake seats  
    function buildSeatsForCar(carId, carData) {
      const seats = {};
      const sourceSeats = (carData && carData.seats) ? carData.seats : {};
      for (let i = 1; i <= TOTAL_SEATS_PER_ROW * TOTAL_ROWS_PER_CAR; i++) {
        seats[i] = { Occupied: true, isFake: true };
      }
      for (const seatNum in sourceSeats) {
        if (sourceSeats[seatNum] && sourceSeats[seatNum].Occupied !== undefined) {
          seats[seatNum] = { 
            Occupied: sourceSeats[seatNum].Occupied, 
            isFake: false 
          };
        }
      }
      return seats;
    }
    
    // render the train view or seats view based on currentView variable
    function render(carIds, carsData) {
      trainEl.innerHTML = '';
      // compute free seats per car for recommendation (independent of view)
      let recommendation = null; // {carIndex, free, total}
      let totalFreeAllCars = 0;
      if (Array.isArray(carIds)) {
        carIds.forEach((carId, idx) => {
          const carData = carsData ? carsData[carId] : null;
          const seatsObj = buildSeatsForCar(carId, carData);
          let occupied=0, total=0;
          for (const s in seatsObj) { total++; if (seatsObj[s].Occupied) occupied++; }
          const free = total - occupied;
          totalFreeAllCars += free;
          if (!recommendation || free > recommendation.free) {
            recommendation = { carIndex: idx + 1, free, total };
          }
        });
      }
      // update best car box early so it shows in both views
      if (recommendation) {
        if (totalFreeAllCars <= 0) {
          bestCarBox.classList.add('full');
            bestCarBox.innerHTML = 'The train is full! <span class="car-num" style="visibility:hidden">Car 00</span><br/><small style="visibility:hidden">&nbsp;</small>';
          bestCarBox.style.display = 'block';
        } else {
          bestCarBox.classList.remove('full');
          bestCarBox.innerHTML = `The best car for you is: <span class="car-num">Car ${recommendation.carIndex}</span><br/><small>${recommendation.free} free seats out of ${recommendation.total}</small>`;
          bestCarBox.style.display = 'block';
        }
      } else {
        bestCarBox.style.display = 'none';
      }
      if (currentView === 'train') {
        // train view: show colored cars without showing seats
        carIds.forEach((carId, index) => {
          const carData = carsData[carId];
          const seats = buildSeatsForCar(carId, carData);
          // calculate number of occupied and free seats
          let occupied = 0, total = 0;
          for (const s in seats) {
            total++;
            if (seats[s].Occupied) occupied++;
          }
          const free = total - occupied;
          const percentFree = (free / total) * 100;
          // determine car color based on free seats percentage
          const color =
            percentFree < 10 ? '#e6a3a3' :      
            percentFree > 50 ? '#a9d6a9' :      
            '#f3d6a2';
          const carDiv = document.createElement('div');
          carDiv.className = 'car';
          const numDiv = document.createElement('div');
          numDiv.className = 'num';
          numDiv.textContent = `Car ${index + 1}`;
          carDiv.appendChild(numDiv);
          const seatsDiv = document.createElement('div');
          seatsDiv.className = 'seats';
          seatsDiv.style.background = color;
          seatsDiv.innerHTML = `<div class="free-seats-text">${free} free seats</div>`;
          carDiv.appendChild(seatsDiv);
          trainEl.appendChild(carDiv);
        });
        // update legend for train view
        updateLegend(currentView);
        return;
      }
      else {
        carIds.forEach((carId, index) => {
          // seats view: show all seats in each car
          const carData = carsData[carId];
          const seats = buildSeatsForCar(carId, carData);
          const carDiv = document.createElement('div');
          carDiv.className = 'car';
          const seatsHtml = [];
          seatsHtml.push(`<div class="num">Car ${index + 1}</div>`);
          seatsHtml.push(`<div class="seats">`);
          for (let row = 0; row < TOTAL_ROWS_PER_CAR; row++) {
            // add gap between middle rows
            const middle =
              row === Math.floor(TOTAL_ROWS_PER_CAR / 2) - 1 ? ' middle-gap' : '';
            seatsHtml.push(`<div class="seats-row${middle}">`);          
            for (let col = 0; col < TOTAL_SEATS_PER_ROW; col++) {
              // calculate seat number
              const seatNumber = (row + 1) + (col * TOTAL_ROWS_PER_CAR);
              const item = seats[seatNumber] || { Occupied: true, isFake: true };
              const dist = item.Occupied ?? true;
              // determine seat color based on distance
              let color = 'gray';
              if (dist) color = 'red';
              else color = 'green';
              // dashed border for fake seats
              const border = item.isFake
                ? '2px dashed rgba(0,0,0,0.25)'
                : '2px solid transparent';
              seatsHtml.push(`<div class="seat" style="background:${color};border:${border}"></div>` );
              //seatsHtml.push(`<div class="seat" style="background:${color};border:${border}">${dist}</div>` );
            }
            seatsHtml.push(`</div>`);
          }
          seatsHtml.push(`</div>`);
          carDiv.innerHTML = seatsHtml.join('');
          trainEl.appendChild(carDiv);
          // update legend for seats view
          updateLegend(currentView);
        });
      }
    }

    //function refreshFakeLocally() {
    //  if (!latestCarIds || !latestCarsData) return;
    //    render(latestCarIds, latestCarsData);
    //console.log('refreshFakeLocally called at', new Date().toLocaleTimeString());
    //}
    
    // update legend based on current view
    function updateLegend(view) {
      legendEl.style.display = 'flex';
      if (view === 'train') {
        legendEl.innerHTML = `
          <span><span class="dot" style="background:#e6a3a3"></span>Less than 10% free</span>
          <span><span class="dot" style="background:#f3d6a2"></span>10â€“50% free</span>
          <span><span class="dot" style="background:#a9d6a9"></span>More than 50% free</span>
        `;
      } else if (view === 'seats') {
        legendEl.innerHTML = `
          <span><span class="dot" style="background:red"></span>Occupied</span>
          <span><span class="dot" style="background:green"></span>Vacant</span>
        `;
      }
    }
    
    // function to draw a train by its number
    function drawTrain(trainNum) {
      trainInput.value = trainNum;
      checkBtn.click();
    }

    // Update the top-right card with current train details
    async function updateCurrentTrainCard(trainNum) {
      try {
        if (!trainNum) { currentTrainBar.style.display = 'none'; return; }
        const dbRef = ref(db, 'schedule');
        const snapshot = await get(dbRef);
        let depTime = null;
        // derive dummy destination/platform in a stable way
        const DESTS = [
          'Haifa', 'Tel Aviv', 'Jerusalem', 'Beer Sheva', 'Ashdod',
          'Ashkelon', 'Netanya', 'Herzliya', 'Lod', 'Modi\'in'
        ];
        const hashNum = (str) => {
          let h = 0; for (let i = 0; i < str.length; i++) h = (h * 31 + str.charCodeAt(i)) >>> 0; return h;
        };
        const formatTime = (t) => {
          const d = new Date(t);
          const hh = String(d.getHours()).padStart(2,'0');
          const mm = String(d.getMinutes()).padStart(2,'0');
          return `${hh}:${mm}`;
        };
        let destination = null;
        let platform = null;
        const now = Date.now();

        if (snapshot.exists()) {
          const schedule = snapshot.val();
          let best = { t: Infinity, entry: null };
          for (const date in schedule) {
            const day = schedule[date];
            if (!day || typeof day !== 'object') continue;
            for (const ts in day) {
              const entry = day[ts];
              const tNum = Number(ts);
              const trainField = entry && (entry.train ?? entry.trainNumber ?? entry.number);
              if (String(trainField) !== String(trainNum)) continue;
              if (Number.isFinite(tNum) && tNum >= now && tNum < best.t) {
                best = { t: tNum, entry };
              }
            }
          }
          if (best.entry) {
            depTime = best.t;
            destination = best.entry.destination || null;
            platform = best.entry.platform || null;
          }
        }

        // Fallbacks/dummies if missing
        const tStr = String(trainNum);
        const h = hashNum(tStr);
        if (!destination) destination = DESTS[h % DESTS.length];
        if (!platform) platform = `${String.fromCharCode(65 + (h % 6))}${(h % 12) + 1}`; // A-F + 1-12
        const timeText = depTime ? formatTime(depTime) : 'â€”';

        // Bar version content (single line groups)
        currentTrainBar.innerHTML = `
          <span><span class="label">Train:</span><span class="value">${tStr}</span></span>
          <span><span class="label">Dest:</span><span class="value">${destination}</span></span>
            <span><span class="label">Plat:</span><span class="value">${platform}</span></span>
          <span><span class="label">Dep:</span><span class="value">${timeText}</span></span>
        `;
        currentTrainBar.style.display = 'flex';
      } catch (e) {
        console.error('Failed to update current train card:', e);
        currentTrainBar.style.display = 'none';
      }
    }

    // Render upcoming trains into the scrollable list
    function renderUpcoming(upcoming) {
      if (!Array.isArray(upcoming) || upcoming.length === 0) {
        upcomingContainer.style.display = 'none';
        upcomingListEl.innerHTML = '';
        return;
      }
      upcomingContainer.style.display = 'block';
      // Helpers to generate stable dummy values
      const DESTS = [
        'Haifa', 'Tel Aviv', 'Jerusalem', 'Beer Sheva', 'Ashdod',
        'Ashkelon', 'Netanya', 'Herzliya', 'Lod', 'Modi\'in'
      ];
      const hashNum = (str) => {
        let h = 0;
        for (let i = 0; i < str.length; i++) {
          h = (h * 31 + str.charCodeAt(i)) >>> 0;
        }
        return h;
      };
      const formatTime = (t) => {
        const d = new Date(t);
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        return `${hh}:${mm}`;
      };
      const formatDateDDMMYYYY = (val) => {
        // If value is a schedule key like "YYYY-MM-DD"
        if (typeof val === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(val)) {
          const [y, m, d] = val.split('-');
          return `${d}/${m}/${y}`;
        }
        // If value is a timestamp or Date
        const d = val instanceof Date ? val : new Date(val);
        if (!isNaN(d)) {
          const day = String(d.getDate()).padStart(2, '0');
          const mon = String(d.getMonth() + 1).padStart(2, '0');
          const yr = d.getFullYear();
          return `${day}/${mon}/${yr}`;
        }
        // Fallback to raw string
        return String(val ?? '');
      };

      const header = `
        <div class="board-header board-grid">
          <div class="board-cell">Train</div>
          <div class="board-cell">Destination</div>
          <div class="board-cell">Platform</div>
          <div class="board-cell">Date</div>
          <div class="board-cell">Time</div>
        </div>`;

      const rows = upcoming.map(item => {
        const tStr = String(item.train);
        const h = hashNum(tStr);
        const dest = (item.destination !== undefined && item.destination !== null && String(item.destination).trim() !== '')
          ? String(item.destination)
          : DESTS[h % DESTS.length];
        // Prefer real platform from DB when available; otherwise use the prior dummy value
        let gate;
        if (item.platform !== undefined && item.platform !== null && String(item.platform).trim() !== '') {
          gate = String(item.platform);
        } else {
          const gateLetter = String.fromCharCode(65 + (h % 6)); // A-F
          const gateNum = (h % 12) + 1; // 1-12
          gate = `${gateLetter}${gateNum}`;
        }
        const timeText = formatTime(item.time);
        const dateText = formatDateDDMMYYYY(item.date || item.time);
        return `<div class="upcoming-item board-grid" data-train="${tStr}">
                  <div class="board-cell board-train">${tStr}</div>
                  <div class="board-cell board-dest">${dest}</div>
                  <div class="board-cell board-gate">${gate}</div>
                  <div class="board-cell board-date">${dateText}</div>
                  <div class="board-cell board-time">${timeText}</div>
                </div>`;
      });
      upcomingListEl.innerHTML = header + rows.join('');
      // Click to open train
      Array.from(upcomingListEl.querySelectorAll('.upcoming-item')).forEach(el => {
        el.addEventListener('click', () => {
          const t = el.getAttribute('data-train');
          if (t) drawTrain(t);
        });
      });
    }

    // Subscribe to schedule and maintain the upcoming list
    function subscribeUpcoming() {
      const scheduleRef = ref(db, 'schedule');
      // Clean up previous subscription if exists
      if (typeof scheduleUnsub === 'function') scheduleUnsub();
      scheduleUnsub = onValue(scheduleRef, (snapshot) => {
        const data = snapshot.val();
        if (!data) {
          renderUpcoming([]);
          return;
        }
        const now = Date.now();
        const upcoming = [];
        // Flatten all schedule entries into an array
        for (const dateKey in data) {
          const day = data[dateKey];
          if (!day || typeof day !== 'object') continue;
          for (const tsKey in day) {
            const entry = day[tsKey];
            const timeNum = Number(tsKey);
            if (!Number.isFinite(timeNum)) continue;
            const trainNum = entry && (entry.train ?? entry.trainNumber ?? entry.number);
            if (!trainNum) continue;
            if (timeNum >= now) {
              // include destination and platform if present on the schedule entry
              const destination = entry && (entry.destination ?? entry.dest ?? entry.to ?? null);
              const platform = entry && entry.platform;
              upcoming.push({ train: String(trainNum), time: timeNum, date: dateKey, destination, platform });
            }
          }
        }
        // Sort ascending and limit the list
        upcoming.sort((a, b) => a.time - b.time);
        const limited = upcoming.slice(0, 20);
        renderUpcoming(limited);
      }, (err) => {
        console.error('Error listening to schedule:', err);
        renderUpcoming([]);
      });
    }

    //const intervalId = setInterval(refreshFakeLocally, FAKE_UPDATE_MS);
    
    //setTimeout(refreshFakeLocally, 500);

    // event listeners for check button
    checkBtn.addEventListener('click', () => {
      // get train number from input
      const trainNum = trainInput.value.trim();
      if (!trainNum) {
        alert("Please enter train number");
        return;
      }
      // Update the current train info card
      updateCurrentTrainCard(trainNum);
      // Keep current UI while new data loads for smoother UX (no blank flicker)
      // unsubscribe from previous listeners to previous train and cars
      if (typeof unsub === 'function') unsub();
      carUnsubscribes.forEach(unsubFn => {
        if (typeof unsubFn === 'function') unsubFn();
      });
      carUnsubscribes = [];
      // get cars for the train and listen to changes in real-time
      const carsRef = ref(db, `trains/${trainNum}/cars`);
      // get unsubscribe function and 
      unsub = onValue(
        carsRef,
        async (snapshot) => {
          const carIds = snapshot.val();
          if (!carIds || carIds.length === 0) {
            trainEl.innerHTML = '<i>No data or no such train</i>';
            latestCarIds = null;
            latestCarsData = null;
            return;
          }
          // ???????????????
          carUnsubscribes.forEach(unsubFn => {
            if (typeof unsubFn === 'function') unsubFn();
          });
          carUnsubscribes = [];
          const carsData = {};
          latestCarIds = carIds;
          // listen to each car data changes and get their seats
          carIds.forEach(carId => {
            const carRef = ref(db, `cars/${carId}`);
            const carUnsub = onValue(carRef, (carSnapshot) => {
              const carData = carSnapshot.val();
              if (carData) {
                carsData[carId] = carData;
                latestCarsData = carsData;
                // Render incrementally as data arrives for smoother updates
                scheduleRender();
              }
            }, (err) => {
              console.error(`Error listening to car ${carId}:`, err);
            });
            carUnsubscribes.push(carUnsub);
          });
        },
        (err) => {
          console.error('RTDB error', err);
          trainEl.innerHTML = '<i>Error</i>';
        }
      );
    });

    // event listeners for view toggle buttons
    // train view button
    trainViewBtn.addEventListener('click', () => {
      currentView = 'train';
      trainViewBtn.classList.add('active');
      seatsViewBtn.classList.remove('active');
      render(latestCarIds, latestCarsData);
    });

    // seats view button
    seatsViewBtn.addEventListener('click', () => {
      currentView = 'seats';
      seatsViewBtn.classList.add('active');
      trainViewBtn.classList.remove('active');
      render(latestCarIds, latestCarsData);
    });

    // event listener for nearest train button
    nearestBtn.addEventListener('click', async () => {
    try {
        // fetch schedule from database
        const dbRef = ref(db, 'schedule');
        const snapshot = await get(dbRef);
        if (!snapshot.exists()) {
          console.log('No schedule found');
          return;
        }
        // find the nearest train based on current time
        const schedule = snapshot.val();
        const now = Date.now(); 
        let nearestTime = Infinity;
        let nearestTrain = null;
        // iterate through schedule to find the nearest train
        for (const date in schedule) {
          const daySchedule = schedule[date];
          for (const timestamp in daySchedule) {
            const trainInfo = daySchedule[timestamp];
            const time = Number(timestamp);
            if (time >= now && time < nearestTime) {
              nearestTime = time;
              nearestTrain = trainInfo.train;
            }
          }
        }
        if (nearestTrain) {
          console.log(`The nearest train is â„–${nearestTrain}`);
          // draw the train
          drawTrain(nearestTrain);
        } else {
          console.log('No trains available in the future');
        }
      } catch (error) {
        console.error('Error:', error);
      }
    });

    // Start schedule subscription for the upcoming trains strip
    subscribeUpcoming();


    // clean up on page unload
    window.addEventListener('beforeunload', () => {
      if (typeof unsub === 'function') unsub();
      carUnsubscribes.forEach(unsubFn => {
        if (typeof unsubFn === 'function') unsubFn();
      });
      if (typeof scheduleUnsub === 'function') scheduleUnsub();
    });
  </script>
</body>
</html>